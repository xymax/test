SE

多线程

1. 进程与线程

* 进程是OS中资源分配的最小单元
* 进程是OS中任务分配的最小单元
* 创建于销毁一个线程的开销要比一个进程小的多，线程间通信也比进程间容易的多
* 线程间通信：join（）。wait/notify。yield。sleep

2. 多线程常用操作方法

* sleep：运行--->阻塞，当前线程立即交出CPU，进入阻塞态，不会释放对象锁
* yield：运行--->就绪，当系统调度交出CPU，进入就绪状态，不会释放对线锁，只会让相同优先级的线程获取CPU。
* join：运行--->阻塞，进入阻塞态，会释放对象锁。（join内部就是wait方法）
* wait：运行--->阻塞，会释放对象锁，必须与synchronized搭配使用
* notify：阻塞--->就绪，必须在同步方法或同步代码块中使用
*  创建          就绪        运行        终止





​    阻塞

* 守护线程与用户线程
* 默认创建的都是用户线程----主线程
* 守护线程：在后台执行，只要java中存在任意一个用户线程没有终止，守护线程就一直运行
* 当JVM中最后一个用户线程终止，守护线程会随着JVM一同停止，GC进程。



3. 线程同步

* 多线程三个特性（原子性、可见性、有序性）任意一个不满足，都存在线程安全问题.

  * synchronize实现线程安全

    - 同步代码块

      ​        synchronize（锁的对象）{}

      ​         -普通类

      ​         -类，class

    - 同步方法

    ​                 -成员同步方法：锁的是当前对象this

    ​                 -静态同步方法：锁的是类的反射对象

    * synchronize底层实现（对象的Monitor机制）
    * 任意一个对象都有MOnitor，synchronized对象锁实际上就是获取对象的Moniter。
    * 当前线要想要获得该锁的Monitor的流程
    * 先判断锁对象得Monitor计数器是否为0；
      * 为0：表示此时Monitor还未被任何线程持有，当线程获取Monitor，并将线程置为自己，将Monitor的值+1；
      * 不为0：表示Monitor已经被线程持有，判断线程获取Monitor